{\rtf1\ansi\ansicpg1252\deff0\nouicompat{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\colortbl ;\red255\green255\blue0;}
{\*\generator Riched20 10.0.14393}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\f0\fs40\lang9 94)Module Introduction\par
\fs24 what are services?\par
consider application in figure 1, we got 4 components- App,About,User,Userdetails. we might have some methods in those components.lets say we want to log data to console in About and UserDetail Component. so we are basically duplicationg our code in 2 different components. lets say in UserComponent we also want to access some data, some array of users may be and also we dnt know whther we will use it some other part of our application. Both useCases - Duplication of code and data storage (providing data) are typical use cases for service, bcoz service is basically just another piece in your angular app, another class you can add which acts as a central repository as central business unit you can say, something where you can store, where you can centralize your code. \par
so we could ceeate a logService to centralize our log statement. we can create userService to manage data storage here\par
\fs40 95)Why would we need service?\par
\fs24 here is example code, we can create some accounts. we start with 3 accounts here at bottom. we can switch status of these accounts and whenver i do it i log something to console. we create a new account then also we log info on console. overal what we got here is logging and data storage, so general tasks which might be centralized. we also communicate between components,that's other area where services can be really helpful.\par
see code, in app.compoent all things come togather. we use property and event binding to pass data around.i.e from child to parent and then from parent to child. This is what we saw previously.\par
all is working fine, but we get very complex setup to pass data around even though app is very simple. now we will see how services can help us and what we have to watch out for.\par
\fs40 96)Creating a logging service\par
\fs24 here we will build a service that takes away the logging task i.e  service where we can log data.  so we create a file names-\par
\b logging.service\b0 (run ng g s logging, it will creaate this file,Name of Class is LoggingService)\par
it is naming convention that tells us that this file is a service.then we export our class as we do with components and directives. now we use @Component and @Directive to make a class component and directive. \b we dnt need any decorator to make a class service.\par
\b0 we define \b logStatusChange\b0  method to log anything on console. with that we centralize this code. now we want to use this service in other components.one way is to import class and create object of that class in component class file(in component where we want to use this service).then we can call functions of service using that object. code-\par
\b import \{LoggingService \} from "../logging.service";\par
const service = new LoggingService();\par
 service.logStatusChange(accountStatus);\par
\b0  this works perfectly fine.if we run our code we can use function of service.\par
but this is still wrong, this is importnat this is not correct way of using service in Angular 2. Reason will becomw clear in this module. but generally angular provides a much better way of getting access to your services and therefore you should not create instances manually. lets see in next video which tool angular gives us to get access to our services. code-\par
logging.service.ts-\par
\b import \{ Injectable \} from '@angular/core';\par
@Injectable()\par
export class LoggingService \{\par
constructor() \{ \}\par
  logStatusChange(status: string)\par
  \{\par
    console.log('A server status changed, new status: ' + status);\par
  \}\par
\}\b0\par
\fs40 97)Injecting Logging Service into Components\par
\fs24 that tool is Angular's Dependency Injector. \par
what is dependency Injector?\par
Dependency is something a class of ours will depend on. for example new-account compoent depends on Logging Service because you want to call a method in that service and dependency injector simply injects this dependency, injects an instance of this class into our component automatically.all we need to do is , we need to inform angular that we require such a instance. so how do we inform angular about it. we define constructor in our compoent class(where we want to use our service). there i can bind it to property by using typrscript shortcut of adding an accessor in front of name of argument to instantly create a property with same name and bind the value to it. to this argument we give type, this type is our Service Class(Class that we want to get injected), now typescript dnt know about this service class, so add a import at the top.\par
This simple task informs angular that we need instance of this logging service.now you might ask how do we inform angular or why does this matter if we write this in our constructor? think who gies us instance of this (new-account) compoent?this is a typescript class, so somewhere it needs to get instantiated, so taht something happens in our app.who is responsible for creating our compoentns? Angular ofcourse, because we are placing selectors in our templates and when angular comes across these selectors it gives us instances of our compoents. now since angular is reponsible for instantiating our compoents, angular will need to constructor them correctly. so if we define in constructor that we require some argument, angular will recognize this and it tries to give us that argument, it tries to give us that type. so it knows we want instance oif logginService because we gave that type to our constructor argument.now angular knows what we want but it does'nt know how to give us such an insatnce. we need to do one additiional step-\b we need to provide a service\b0 , provide simply means we tell angular how to create it. how we do it, we add one extra property to object that we pass to @Component decorator,this is providers property. it takes an array as value. in array we specify which type we want to get, in other words class of service that we want to get.now angular knows what we want and how we want. so it gives us instance of service class while creating instance of compoent.\par
now anywhre in our compoent class, we can use this new class variable(which we created using that typescript shortcut, this is of type service class) to access all methods and properties of our service.\par
\b so now we are not creating instance of service class manually, angular does that for us.\b0  why is it better than creating manually? you will see some other advantages later, but this basically lets us stay in angular ecosystem and angular knows how your app works.this code shows how we inject service(service is already created in last lecture) into a component. code-\par
new-account.component.ts-\par
\b import \{ Component, EventEmitter, Output \} from '@angular/core';\par
\highlight1 import \{ LoggingService \} from '../logging.service';\highlight0\par
@Component(\{\par
  selector: 'app-new-account',\par
  templateUrl: './new-account.component.html',\par
  styleUrls: ['./new-account.component.css'],\highlight1\par
  providers: [LoggingService]\par
\highlight0\})\par
export class NewAccountComponent \{\par
  @Output() accountAdded = new EventEmitter<\{name: string, status: string\}>();\par
  constructor(\highlight1 private loggingService :LoggingService\highlight0 )\{\}\par
\par
  onCreateAccount(accountName: string, accountStatus: string) \{\par
    this.accountAdded.emit(\{\par
      name: accountName,\par
      status: accountStatus\par
    \});\par
    \par
    \highlight1 this.loggingService.logStatusChange(accountStatus);\par
\highlight0   \}\par
\}\b0\par
now if we run our code, it works as before but now instead of eriting the code in compoennt class, we injected a service and called its method. we also inject this service in acount.compoent. so now we get this same logging functionality outsourced centralized in a service, so our code is leaner now. this will really help in bigger applications.\par
steps to use servcice-\par
1) define service class(Tell angular what we want)\par
2)Inject service in component(tell angular where we want to use this service)\par
3)provide that service(how we want to use, how many instantces we want to have)\par
\fs44 98)Creating Data Service\par
\fs24 In last lecture we saw how we can use service to centralize a code. now here we will see another typical usecase for a service to store manage our data.in our code without service we store our accounts(data) in app components, then we chain of event and property bindinh to get data to app.compoennt if we want to update some accounts.\par
we create accounts service for that.\par
run\b  ng serve g s accounts\par
\b0  we get accounts.service.ts file and it has AccountsService class.in this service we define array to hold accounts. and then we have methods to add new account and chnage status of existing one. now we dnt have any data in app.component. but we use data in template of app.component.\par
so we inject our service in app.component. we define a accounts property in app.componnert, then take data from service and store it in that accounts property. then we define ngOnInit life cycle hook, as most of iniliazations shoulkd'nt be done in constructor, instead they should be done in ngOnit. when we do this in app.component-\par
\b this.accounts = this.accountsService.accounts;\b0\par
accounts is array in our service,it is of refrence type. this is normal java script behaviour, by setting it equal here, we are getting access to exactly same array as stored in service. now i want to chmage the way how our componnets exchnage data by using property binding and event binding.\par
first we go to new-account.component, here we use event emitter to pass data to app.component(child to parent). now we wnt use that. we inject AccountsService into it. now we want to add data to array in service,so we use addAccount method defined in service.now as array are refrence type, chnage we make in array of service is also reflected in accounts array of app.component.\par
similar we inject our accountsService in account.component also. now we dnt need to emit event when we want to chnage ststua of account, instaed we use method of service to do so.\par
now if we run our program, then if we try to add new server, it is not added but we see message on console. similar if we try to chnage the status of existing server it is not chnages but we see message on console.something is wrong.\par
 reason for this is, we are using different instance of service for all 3 components as we provide this service separately in 3 components. when we add a server, it is added to separate instance of service, but in app.component we loop through diffrent inatance of service.solution to this problem is to use same instance of service in all 3 compoents.\par
\fs44 99)Understanding the Hierarchical Injector\par
\fs24 The angular dependency injector is hierarchical injector that means that if we provide service in some place of our app, lets say on one component, the angular framework knows how to create an instance of that service for this compoent and important \b all it's child component\b0 . and actually this component and it's child compoenent and child components of child components will receive same instance of service. \par
There are other places where we can provide a service too- The highest possible level is AppModule. wehave'nt done this but we will do it shortly.if we provide a service in app.module(@NgModule also has providers property) then the same instance  and that's importnat \b same instance \b0 of service is avalible in our whole app, in all compoennts, in all directives, in all other services, where we inject our service.(yes we can inject services into services).\par
next level for example will be  app component, there app component and all its child compoent do have same instance of the service.This is true for any compoennt, even if we have child of app component and we provide service there, then this component and all its child component will have same instance of service, but not app component, i.e instance dnt propagate up. they only go down the tree of components.\par
the lowest level therefore is single component with no child component. if we provide service there, then this component will have its own instance of the service.this will actually even overwrite if we were to provide same service on higher level. that's what we are doing in our code and because of it we are getting error.\fs44\par
100)How many instances of service should it be?\par
\fs24 In our last lecture we saw Hierarchial dependency injector. This injection behaviour leads to behavioiur of our code that we saw. this is not a bug.In some situation we may want to have d/w instacnces of services for d/w compoennts but not here. here we want to have a single instance. \par
our code has 3 instnaces of accountsService. first one is created in app compoennt. we provide this service in @Component, so it receives its own instance of service, as well al child compoents also receive same instnace. but in new-account and account compoent we overwrite the instance that we get from app component because we again provide this service in @Component in both component classes. now both these compoent have there own instnaces. hence we got 3 instances. how to we fix this? simple, remove service from providers array in both Components, now we are not overwrting the service instnace given by app compoennt. dnt remove service from constructor, we need it there,bcoz that tells angular that we want an instance, providers array tells which instance. so remove service from providers array of both components(in @Component). now we get single inatnace and our app works as expected.\par
\fs40 101)Injecting Services into Services\par
\fs24 In last lectures we learned about hierarchial injector and we can choose between same instance and mutiple instances of same service class. I mentioned that highest possible level is not app.component but it is app.module. so we can alo have a provider property in @NgModule. so in our code now we provide our service in app.module(remove it from providers array in app.component). with this little addition we are making sure that our whole app, everything in our application receives the same instance of service ub=nless we overwrite this as we didi before.with that we can inject the service into another service, because that is not possible by providing it on compoennt level, for that we need to provide it on app module. so lets say i want to log something when i call    in accounts service. we provide both these services in app module.\par
 now we want to call logStatusChange method of logging service in accounts service.\par
so we inject the logging service into accounts service(by mentioning it in constrctor of accounsService).now we have already provided both services in app mpdule. so you might think that angular will provided you inatance of logging service in account service.if we run our code, we get this error on console-\par
\b cnt resolve all parameters for AccountService\b0\par
the reason is if you inject a service into something, this something needs to have some meta data attached to it. now compoannt has some metadata because we use @Compoent, in Directive we use @Directive, In Module we use @NgModule. but service dnt have any metadata. for this puprose we use \b @Injectable \b0  metadata in service, we want to inject another service into it. now after using it , something can be injected into this service. we dnt add @Injectable to service that we want to inject but to service where we want to inject something, receving service.\par
if we dnt want to inject anything in service then we dnt need to have @injectable in our service.\par
steps to inject service A into service B into another service-\par
1)provide service A at module level\par
2)mention service A in constructor of service B(inject service)\par
3)use @Injectable in service B \par
\fs40 102)Using services for Cross-Component Communication\par
\fs24 we saw how services can clean our app. they make code leaner, easy to maintain, and more centralize. you dnt have to built these  complex @Output and @Input chaiins, where we pass events and properties to get data from component A to component B.\par
lets say if we click on button in acount component, for some reason we want to output something in new account component.Normally without services we have to define a custom event in account component, then we have to listen to this event in app.cmponent, then we have to use proeprty binding to pass data from app.component to new account compoment.we go from child to parent then from parent to another child.this very complicated.\par
with services it is easier. lets say in accountsSrvice we want to provide some event which we can trigger in one component and listen to it in another component. we define statusUpdated  event in accountsservice.\par
\b statusUpdated = new EventEmitter<string>();\b0\par
 now we emit this event in account.component(in onSetTo method).we have injected this ervice in  account.component. code-\par
\b this.accountsService.statusUpdated.emit(status);\par
\b0 here we are emitting a event. later in observables section you will learn about another construct you can use to emit events and subscrine to it, insyead of using event emitter. but for now its fine.\par
now in new-account.component we want to listen to it, so i subscribe to this event in constructor of this component's class. because event emitter in end kind of wraps a observable. to subscribe function we pass a callback which get data emitted from event as argument and will be exexcuted when event occurs. code-\par
\b constructor(private loggingService :LoggingService, private accountsService: AccountsService)\par
\{\par
this.accountsService.statusUpdated.subscribe((status: string)=> alert('New Sttaus '+status));\par
\}\par
\b0 now i am not building any chain of property and event binding. i have cross component communication through service with eventEmitter.\fs44\par
}
 