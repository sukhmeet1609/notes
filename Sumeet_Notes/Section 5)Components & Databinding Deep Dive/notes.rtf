{\rtf1\ansi\ansicpg1252\deff0\nouicompat{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\colortbl ;\red255\green0\blue0;\red0\green0\blue255;}
{\*\generator Riched20 10.0.14393}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\f0\fs40\lang9 59)Splitting app into components\par
\fs24 Initially app contains a single component. in this lecture we created 2 new components- cockpit and server-element component. these are child components of app.component.it is good to split your app between components, that way we can reuse them also logic is isolated.\par
so first we need to pass a value from cockpit to app.component, then we need to pass that value from app.compoent to server-elemnt. \par
\b so first we need to pass value from child to parent, then from parent to child.\b0\par
 right now our app is broken we will fix it in coming lectures by passing these value then by using these values.\par
\fs40 60)Property and Data Binding Overview\par
\fs24 now we want to pass data between components.now in basic section we laerned about property and event binding and there we used it for example bind the disabled property of our html element. so we kind of passed the data to that element. same with vent binding when we clicked on HTML button , something happened. this button emitted a event to which we were able to listen.so it it sent us some data, same for input event, we used this data, we passed it to our function by $event.there we got data from input element.this is exactly the behaviour we want with our own component.\par
we need to be able to send data into a component or receive data,receive an event.angular gives us tools to implement this flow.\par
\b\fs22 refer to figure 1\b0\par
\fs24 we can  use property and event binding not only on HTML elemnts and their native elemnts and events as we did this far. we can also use it on directives and we also did this with ngClass and ngStyle, their we used property binding.\par
but and this is important we can use it on our own components and bind to our own custom properties and custom events.we can emit our own events. \par
\fs40 61)Binding to Custom Properties\par
\b\fs24 (Passing data from Parent to child)\par
\b0 here we defined a porperty called element in server-elemnt component. now  this property is part of this component only. we cnt access it from outside. it would be great if we can access this property from app.component. we want to do this, in app.component.html-\par
\b <app-server-element \par
*ngFor="let serverElement of serverElements"\par
   [element]="serverElement"\par
  >\par
</app-server-element>\b0\fs22\par
but we get tis error-\par
cnt bind it element because it is'nt known propertry of app-server-element.\par
but we knw elment is property of server-element component.so why cnt we aceess it, this property is even public. here is answer- By default all properties of components are only accessible inside these compoents not from outside.that is good thing . you dnt want all your properties to be bindable from outside.so we have to be explicit aboit which properties we want to exose to the world. so you want parent component to be able to bind to this property, you need to add something to that elemtn property.you need to add a decorator. remember we said decorators are not only avalible for classes, here we goingn to add one to our property. decorator we want to add is \b @Input,\b0  this is importnat we to execute it, it's like function in the end. we do this in server-element.ts-\par
\b @Input() element: \{type: string, name: string,content:string\};\b0\par
with this we are  successfully exposing this property to the world. so now any parent component, any component hosting our server-element compoent, implementting through it's selector , is now able to bind to element. \par
this is how you can set up custom property binding on your own evnts exposing your own properties, to the componets where you implement these components through selector(parent componets).\par
\fs40 62)Assigning Alias to Custom properties\par

\pard\sa200\sl240\slmult1\fs24 in last lecture we saw how we expose a component property to its parent componet. lets say i want to use diffrent name for \b element \b0  property outside server-element component. we can do this by assigning a lais to elemnt property. how do we do it-\par
in server-element.componet.ts-\par

\pard\sa200\sl276\slmult1\b\fs22 @Input(\highlight1 srvElement\highlight0 ) element: \{type: string, name: string,content:string\};\par
\b0 in app.component.html-\par
\b\fs24 <app-server-element \par
*ngFor="let serverElement of serverElements"\par
   [\highlight1\fs22 srvElement\highlight0\fs24 ]="serverElement"\par
  >\par
</app-server-element>\par
\b0  now element wnt work outside it has to be srvElement i.e we have to bind srvElement we cnt use elemnt for binding outside server-elemnt component.\fs40\par
63)Binding to Custom Events\par
\b\fs24 (passing data from child to parent)\par
\b0 now we want to inform parent component if something chnages in child component.in our code we want to do something in app.component when click buttons in cockpit component.specifally we want to pass data in input fields. we want to pass data whenuser clicks on buttons.\par
so we can emit our own event, how we can inform app.component?\par
In app.component.html, hwere we implment cockpit, it would be great if we can listen to serverCreated(you can name it anything) event. then execute function and pass data to that function with \b $event(it is data emitted by event)\b0 . so we call these methods when our custom events occur in cockpit component. similarly we do same for bluePrintCreated event.\par
app.componenet.html-\par
\b <app-cockpit \par
      (serverCreated)="onServerAdded($event)"\par
      (bluePrintCreated)="onBlueprintAdded($event)">\par
  </app-cockpit>\par
\b0 app.component.ts-\par
\b onServerAdded(serverData:\{serverName: string, serverContent:string\}) \{\par
    this.serverElements.push(\{\par
      type: 'server',\par
      name: serverData.serverName,\par
      content: serverData.serverContent\par
    \});\par
  \}\par
\par
  onBlueprintAdded(blueprintData:\{serverName: string, serverContent:string\}) \{\par
    this.serverElements.push(\{\par
      type: 'blueprint',\par
      name: blueprintData.serverName,\par
      content: blueprintData.serverContent\par
    \});\par
  \}\par
\b0 now in cockpit component we actually need to emit these evnts. so in cockpit component i create 2 new \b properties. \b0 before we used to put @Input() in fornt of them to mark them as propeties you can set from outside.now we want to do the opposite. we want to make sure that both porpeties are evnt ,that we can emit. first to make them events we assign them a value. now EventEmitter is a generic type. In typescript it is indicated by using \b <>, \b0 between these we define type of data that we are goint to emit. here we want to emit our custom object. then add parenthesis at the end to call constructor of EventEmitter and create new EventEmitter object which is now stored in variable serverCreated.similarly we create another event emitter. this is first step. EventEmitter is object in angular framework that allow you to emit your own events. \par
next step is we have to emit event, which we do in function which is called when we click on button. code-\par
\par
in cockpit.component.ts-\par
\b @Output() serverCeeated = new EventEmitter<\{serverName: string, serverContent:string\}>();\par
@Output() blueprintCreated = new EventEmitter<\{serverName: string, serverContent:string\}>();\par
onAddServer() \{\par
this.serverCeeated.emit(\{serverName: this.newServerName, serverContent:this.newServerContent\});\par
  \}\par
onAddBlueprint() \{\par
this.blueprintCreated.emit(\{serverName: this.newServerName, serverContent:this.newServerContent\});\par
  \}\b0\par
now we added @Input() to make a property bindable from outside,now we need to add something to our events to make them listenable from outside.so we add \b @Output().\b0 its not input because we are not passing something into component, we are passing something out of it, we are passing our own event out of the component.\par
now we run our code it is running. Component communication is very important.\par
\fs40 64)Assigning an alias to custom events\par
\fs24 this works just like we assigned alias to custom property.\par
\fs40 65)Custom Property and Event Binding Summary\par
\fs24 what we learnt(Compoent Communication) is very important.this allow us to make our application dynamic using many communication and have them communicate with each other. We saw how we can pass data between parent to child and child to parent.\par
Now one issue you could say with that approach is that if you want to talk between 2 components sitting next to each other it can get kind of complicated to emit a event in one component, change something in parent component and then pass this new data down to child component. amd thesec chains of inputs and ouputs can really grow more complex.\par
this approach worked here but here can be some use cases where distnace between 2 components that should talk to each other is so great that builkding a chain of outputs and inouts is not very practical. that is why in services section, i will show another approach of having components  communicate. that is not better approach, it is just better tool for a specific usecase. approached used here is also used widely, it is perfect for these usecases.\par
\fs40 66)View Encapsulation  \par
\fs24 Angular 2 gives saame attribute to all elemnts in a component.it does it for each component with diffrent uniqoe attribute names. then it adds this attribute to selectors of  all styles defined for this component.In this way styles are only applied to elemnts in that component only.\fs40\par
69)Getting acess to template and DOM with @ViewChild(see copy also)\par
\fs24 in last lecture  we saw localrefrences. now there is another way of getting access to local refrences or to any element acutally directly from within our typescript code. right we are passing the refrences when we call the method and that works fine but sometimes you  want to get access before we call the method. there is a decorator that we can use to get the access. see code in cockpit.component.html\fs22 , see how we get content value.\par
see code and copy\par
with this we get direct access to elements in our DOM in our template through local refrences fetched through @ViewChild and localRefrences passed to functions. now importnat thing to watch out is you should not change the element this bcoz, ofcourse we can do this\par
\b this.serverContentInput.nativeElement.value = "abc";\par
\b0 it is strongly recommended not to do this. you should not acess DOM like this angular offers you better way of accessing the DOM. you will learn about this in directive section.generally you should use other tools like string interpolation and property binding if you want to output something in DOM and not directly mess with any elemnts you can get. even though if you have gotten them through angular.\par
\par
for uses of @view Child-\par
{{\field{\*\fldinst{HYPERLINK https://alligator.io/angular/viewchild-access-component/ }}{\fldrslt{https://alligator.io/angular/viewchild-access-component/\ul0\cf0}}}}\f0\fs22\par
\par
}
 